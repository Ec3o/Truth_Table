# çœŸå€¼è¡¨ç”Ÿæˆå™¨å®ç°

ä¸€ä¸ªåŸºäºWebçš„çœŸå€¼è¡¨ç”Ÿæˆå™¨ï¼Œç¤ºä¾‹demoè¿è¡Œäº[çœŸå€¼è¡¨ç”Ÿæˆå™¨](http://111.229.210.75:8000/)

## ä¸€ã€å®ç°ç†è®ºåˆ†æ

### 1.ç”¨æˆ·è¾“å…¥å¾…è§£æè¡¨è¾¾å¼ï¼Œå‰ç«¯é¡µé¢è·å–è¾“å…¥å¹¶è¯·æ±‚åç«¯

æœ¬é¡¹ç›®ä½¿ç”¨**Go**è¯­è¨€å¼€å‘ï¼Œæ—¨åœ¨æ„å»ºä¸€ä¸ªwebé¡µé¢å¯ç”¨ä¸”å¯åˆ†äº«çš„çœŸå€¼è¡¨ç”Ÿæˆå™¨ã€‚å‰ç«¯**JavaScript**ä»£ç ä¼šå°†ç”¨æˆ·è¾“å…¥çš„è¡¨è¾¾å¼åŠ¨æ€æ›´æ–°å‘åç«¯æ¥å£å‘åŒ…ã€‚

### 2.åç«¯è·å–è¡¨è¾¾å¼å¹¶å°†è¡¨è¾¾å¼è¿›ä¸€æ­¥è§£æä¸ºASTè¡¨è¾¾å¼æ ‘

#### ä»€ä¹ˆæ˜¯ASTï¼Ÿ

**AST**ï¼ˆ**Abstract Syntax Tree**ï¼ŒæŠ½è±¡è¯­æ³•æ ‘ï¼‰æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­ç”¨äºè¡¨ç¤ºç¼–ç¨‹è¯­è¨€è¯­æ³•ç»“æ„çš„ä¸€ç§æ ‘å½¢æ•°æ®ç»“æ„ã€‚åœ¨ç¼–è¯‘å™¨ã€è§£é‡Šå™¨ç­‰è¯­è¨€å¤„ç†å·¥å…·ä¸­ï¼Œ**AST** è¢«å¹¿æ³›åº”ç”¨äºè¯­æ³•åˆ†æã€è¯­ä¹‰åˆ†æå’Œä»£ç ç”Ÿæˆç­‰é˜¶æ®µã€‚

**AST** æ˜¯æºä»£ç çš„æŠ½è±¡è¡¨ç¤ºï¼Œå®ƒå°†æºä»£ç è½¬æ¢ä¸ºæ ‘å½¢ç»“æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨æºä»£ç ä¸­çš„ä¸€ä¸ªè¯­æ³•ç»“æ„ï¼Œå¦‚è¡¨è¾¾å¼ã€è¯­å¥ã€å‡½æ•°ã€å˜é‡ç­‰ã€‚æ ‘çš„æ ¹èŠ‚ç‚¹è¡¨ç¤ºæ•´ä¸ªæºä»£ç ï¼Œè€Œå­èŠ‚ç‚¹è¡¨ç¤ºæºä»£ç çš„å„ä¸ªéƒ¨åˆ†ã€‚

åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œ**AST** çš„æ„å»ºè¿‡ç¨‹é€šå¸¸åŒ…æ‹¬è¯æ³•åˆ†æå’Œè¯­æ³•åˆ†æã€‚è¯æ³•åˆ†æå™¨è´Ÿè´£å°†æºä»£ç å­—ç¬¦ä¸²è½¬æ¢ä¸ºä¸€ç³»åˆ—çš„ **Token**ï¼ˆæ ‡è®°ï¼‰ï¼Œè€Œè¯­æ³•åˆ†æå™¨åˆ™æ ¹æ®è¿™äº› **Token** æ„å»º **AST**ã€‚

é€šè¿‡éå† **AST**ï¼Œå¯ä»¥è¿›è¡Œè¯­æ³•åˆ†æã€è¯­ä¹‰åˆ†æå’Œä»£ç ç”Ÿæˆç­‰æ“ä½œã€‚ç¼–è¯‘å™¨æˆ–è§£é‡Šå™¨å¯ä»¥æ ¹æ® **AST** è¿›è¡Œä¼˜åŒ–ã€é”™è¯¯æ£€æŸ¥å’Œä»£ç ç”Ÿæˆç­‰å·¥ä½œï¼Œä»è€Œå®ç°å¯¹æºä»£ç çš„åˆ†æå’Œå¤„ç†ã€‚

### 3.æå–è¡¨è¾¾å¼ä¸­çš„å˜å…ƒä¸ªæ•°ï¼Œå¹¶ç”Ÿæˆä¸åŒçš„ç‹¬ç«‹åˆå§‹å˜å…ƒå€¼ï¼Œå…±2^nè¡ŒçœŸå€¼å–å€¼æƒ…å†µ

### 4.å°†ASTæ ‘å‰²è£‚ä¸ºå¤šä¸ªèŠ‚ç‚¹ï¼Œç”¨äºåç»­éå†ç”ŸæˆçœŸå€¼è¡¨

### 5.éå†ASTæ ‘ï¼Œç”ŸæˆçœŸå€¼è¡¨å–å€¼

### 6.å°†çœŸå€¼è¡¨å¤„ç†ä¸ºJsonå¹¶è¿”å›æ•°æ®åˆ°å‰ç«¯

### 7.å‰ç«¯æ ¹æ®è¿”å›çš„Jsonæ•°æ®æ¸²æŸ“çœŸå€¼è¡¨

## äºŒã€å®ä¾‹ä»£ç å®ç°

### 1.ç”¨æˆ·è¾“å…¥å¾…è§£æè¡¨è¾¾å¼ï¼Œå‰ç«¯é¡µé¢è·å–è¾“å…¥å¹¶è¯·æ±‚åç«¯

```html
<label for="expression">è¾“å…¥ä½ çš„é€»è¾‘è¡¨è¾¾å¼ğŸ¥°</label>
```

```javascript
<script>
    // è·å–JsonåŠŸèƒ½
    function fetchTruthTableData() {
        const exprInput = encodeURIComponent(document.getElementById('expression').value);
        if (!exprInput) {
            clearTables();
            return;
        }
        fetch('/api/data?exp=' + exprInput) //ä½¿ç”¨ç”¨æˆ·è¾“å…¥è¡¨è¾¾å¼
            .then(function (response) {
                if (!response.ok) {
                    throw new Error("There was a problem with the fetch operation: " + response.statusText);
                }
                return response.json(); // è§£æJsonæ•°æ®æµ
            })
            .then(function (data) {
                var tableId = data.length > 10 ? "truthTableRight" : "truthTableLeft"; // åˆ¤æ–­è¡¨å•åŒºåŸŸ
                displayTruthTable(data, tableId);
            })
            .catch(function (error) {
                console.error(error);
            });
    }

    // æ¸…é™¤è¡¨å•
    function clearTables() {
        document.getElementById("truthTableLeft").innerHTML = "";
        document.getElementById("truthTableRight").innerHTML = "";
    }
    function replaceLogicSymbols(expression) {
        return expression.replace(/!/g, 'Â¬')
            .replace(/&/g, 'â‹€')
            .replace(/\|/g, 'â‹');
    }
    // ç›‘å¬å™¨ï¼Œç›‘æµ‹åˆ°æ•°æ®å˜åŒ–æ—¶è°ƒç”¨fetchTruthTableDataå‡½æ•°
    document.getElementById('expression').addEventListener('input', fetchTruthTableData);

    // åˆå§‹åŒ–è¡¨å•
    fetchTruthTableData();
</script>
```

**åç«¯åˆ†è¯è§£æå™¨**

```go
func Lexer(input string) []Token {
    var tokens []Token
    var currentVar string
    //åˆ¤æ–­å­—ç¬¦æ˜¯å¦ä¸ºæ ‡å‡†å˜å…ƒ
    isVarChar := func(ch rune) bool {
       return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')
    }
    //å®šä¹‰åŒ¿åå‡½æ•°ç”¨äºæ·»åŠ å˜å…ƒ
    commitVar := func() {
       if currentVar != "" {
          tokens = append(tokens, Token{Type: TokenTypeVar, Value: currentVar})
          currentVar = ""
       }
    }

    for _, ch := range input {
       switch {
       case isVarChar(ch):
          currentVar += string(ch)
       case ch == '&':
          commitVar()
          tokens = append(tokens, Token{Type: TokenTypeAnd})
       case ch == '|':
          commitVar()
          tokens = append(tokens, Token{Type: TokenTypeOr})
       case ch == '!':
          commitVar()
          tokens = append(tokens, Token{Type: TokenTypeNot})
       case ch == 'â†’':
          commitVar()
          tokens = append(tokens, Token{Type: TokenTypeImplies})
       case ch == 'â‡”':
          commitVar()
          tokens = append(tokens, Token{Type: TokenTypeEquivalent})
       case ch == '(':
          commitVar()
          tokens = append(tokens, Token{Type: TokenTypeLparen})
       case ch == ')':
          commitVar()
          tokens = append(tokens, Token{Type: TokenTypeRparen})
       default:
          // å¿½ç•¥å…¶ä»–ç¬¦å·
       }
    }

    commitVar() // æäº¤æœ€åä¸€ä¸ªå˜å…ƒ
    return tokens
}
```

### 2.åç«¯è·å–è¡¨è¾¾å¼å¹¶å°†è¡¨è¾¾å¼è¿›ä¸€æ­¥è§£æä¸ºASTè¡¨è¾¾å¼æ ‘

```go
func ExpressHandler(c *gin.Context) {
    expression := c.Query("exp") //è·å–è¡¨è¾¾å¼å‚æ•°
    tokens := Lexer(expression)  //è§£æè¡¨è¾¾å¼ä¸ºTokenå—
    var pos int
    ast, err := parseEquivalent(tokens, &pos)
    printAST(ast, 0)
    if err != nil {
       fmt.Println("Error parsing expression:", err)
       c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
       return
    }
    variables := ExtractVariables(expression)           //æå–æ‰€æœ‰çš„å˜é‡
    truthTable, err := truthTableToJson(ast, variables) // ä¿®æ”¹äº†å‡½æ•°å
    if err != nil {
       fmt.Println("Error generating truth table:", err)
       c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()}) // ä¿®æ”¹äº†é”™è¯¯æ¶ˆæ¯
       return
    }
    c.Header("Content-Type", "application/json")
    c.JSON(http.StatusOK, truthTable)
}
```

ASTè§£æå™¨å‡½æ•°

```go
func parsePrimary(tokens []Token, pos *int) (Expr, error) {
    if *pos >= len(tokens) {
       return nil, fmt.Errorf("unexpected end of expression")
    }

    token := tokens[*pos]
    switch token.Type {
    case TokenTypeVar:
       *pos++
       return Var{Name: token.Value}, nil
    case TokenTypeLparen:
       *pos++
       expr, err := parseEquivalent(tokens, pos) // ä»æœ€ä½ä¼˜å…ˆçº§çš„æ“ä½œç¬¦â€˜ç­‰å€¼â€™å¼€å§‹
       if err != nil {
          return nil, err
       }
       if *pos >= len(tokens) || tokens[*pos].Type != TokenTypeRparen {
          return nil, fmt.Errorf("expected ')' at position %d", *pos)
       }
       *pos++
       return expr, nil
    default:
       return nil, fmt.Errorf("unexpected token '%s' at position %d", token.Value, *pos)
    }
}

func parseNot(tokens []Token, pos *int) (Expr, error) {
    if *pos < len(tokens) && tokens[*pos].Type == TokenTypeNot {
       *pos++
       expr, err := parsePrimary(tokens, pos)
       if err != nil {
          return nil, err
       }
       return Not{Operand: expr}, nil
    }
    return parsePrimary(tokens, pos)
}

func parseAnd(tokens []Token, pos *int) (Expr, error) {
    expr, err := parseNot(tokens, pos)
    if err != nil {
       return nil, err
    }

    for *pos < len(tokens) && tokens[*pos].Type == TokenTypeAnd {
       *pos++
       rightExpr, err := parseNot(tokens, pos)
       if err != nil {
          return nil, err
       }
       expr = And{Left: expr, Right: rightExpr}
    }

    return expr, nil
}

func parseOr(tokens []Token, pos *int) (Expr, error) {
    expr, err := parseAnd(tokens, pos)
    if err != nil {
       return nil, err
    }

    for *pos < len(tokens) && tokens[*pos].Type == TokenTypeOr {
       *pos++
       rightExpr, err := parseAnd(tokens, pos)
       if err != nil {
          return nil, err
       }
       expr = Or{Left: expr, Right: rightExpr}
    }

    return expr, nil
}

func parseImplies(tokens []Token, pos *int) (Expr, error) {
    expr, err := parseOr(tokens, pos)
    if err != nil {
       return nil, err
    }

    for *pos < len(tokens) && tokens[*pos].Type == TokenTypeImplies {
       *pos++
       rightExpr, err := parseImplies(tokens, pos) // é€’å½’è°ƒç”¨parseImpliesæ¥å¤„ç†è•´æ¶µçš„å³ç»“åˆæ€§
       if err != nil {
          return nil, err
       }
       expr = Implies{Left: expr, Right: rightExpr}
    }

    return expr, nil
}

// æ­¥éª¤6:å¤„ç†ç­‰ä»·(â‡”)
func parseEquivalent(tokens []Token, pos *int) (Expr, error) {
    expr, err := parseImplies(tokens, pos) //ä»è•´æ¶µå¼€å§‹è§£æï¼Œå› ä¸ºå®ƒå…·æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§
    if err != nil {
       return nil, err
    }
    //æ­¤å¾ªç¯å°†å¤„ç†ç­‰ä»·è¡¨è¾¾å¼é“¾(ä¾‹å¦‚ï¼Œaâ‡”bâ‡”c)
    for *pos < len(tokens) && tokens[*pos].Type == TokenTypeEquivalent {
       *pos++ //ç§»è¿‡'â‡”'ç¬¦å·

       //è§£æç­‰ä»·çš„å³è¾¹ã€‚æ³¨æ„è¿™ä¸€ç‚¹å¾ˆé‡è¦
       //æˆ‘ä»¬å†æ¬¡è°ƒç”¨parseImpliesä»¥ç¡®ä¿æ­£ç¡®çš„ç»“åˆæ€§å’Œä¼˜å…ˆçº§ã€‚
       //è¿™æ„å‘³ç€'aâ‡”bâ‡”c'è¢«è§†ä¸º'aâ‡”(bâ‡”c)'ã€‚
       rightExpr, err := parseImplies(tokens, pos)
       if err != nil {
          return nil, err
       }

       //å°†å½“å‰è¡¨è¾¾å¼ä¸æ–°çš„å³ä¾§ç»„åˆæˆä¸€ä¸ªæ–°çš„ç­‰æ•ˆè¡¨è¾¾å¼ã€‚
       expr = Equivalent{Left: expr, Right: rightExpr}
    }

    return expr, nil
}
```

### 3.æå–è¡¨è¾¾å¼ä¸­çš„å˜å…ƒä¸ªæ•°ï¼Œå¹¶ç”Ÿæˆä¸åŒçš„ç‹¬ç«‹åˆå§‹å˜å…ƒå€¼ï¼Œå…±2^nè¡ŒçœŸå€¼å–å€¼æƒ…å†µ

```go
// æå–è¡¨è¾¾å¼ä¸­çš„å˜é‡ï¼ˆé€’å½’åœ°å¤„ç†å¤åˆè¡¨è¾¾å¼ï¼‰
func extractVariablesFromExpr(expr Expr, parentVars []string) []string {
    var variables []string
    // æ ¹æ®è¡¨è¾¾å¼ç±»å‹é€’å½’æå–å˜é‡
    switch e := expr.(type) {
    case And:
       variables = append(variables, extractVariablesFromExpr(e.Left, parentVars)...)
       variables = append(variables, extractVariablesFromExpr(e.Right, parentVars)...)
    case Or:
       variables = append(variables, extractVariablesFromExpr(e.Left, parentVars)...)
       variables = append(variables, extractVariablesFromExpr(e.Right, parentVars)...)
    case Not:
       variables = append(variables, extractVariablesFromExpr(e.Operand, parentVars)...)
    case Var:
       variables = append(variables, e.Name)
    }
    // ç¡®ä¿å˜é‡åˆ—è¡¨ä¸­çš„å˜é‡æ˜¯å”¯ä¸€çš„
    variables = append(variables, parentVars...)
    sort.Strings(variables)
    return removeDuplicates(variables)
}
```

```go
func evaluateExpressionAndSubexpressions(expr Expr, combination map[string]bool) map[string]int {
    result := make(map[string]int)

    // è®¡ç®—å½“å‰è¡¨è¾¾å¼çš„å€¼
    if expr.Evaluate(combination) {
       result[expr.String()] = 1
    } else {
       result[expr.String()] = 0
    }

    // æ ¹æ®è¡¨è¾¾å¼ç±»å‹ï¼Œé€’å½’å¤„ç†å­è¡¨è¾¾å¼
    switch e := expr.(type) {
    case And:
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Left, combination))
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Right, combination))
    case Or:
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Left, combination))
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Right, combination))
    case Not:
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Operand, combination))
    case Implies:
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Left, combination))
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Right, combination))
    case Equivalent:
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Left, combination))
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Right, combination))
    }

    return result
}
```

### 4.å°†ASTæ ‘å‰²è£‚ä¸ºå¤šä¸ªèŠ‚ç‚¹ï¼Œç”¨äºåç»­éå†ç”ŸæˆçœŸå€¼è¡¨

### 5.éå†ASTæ ‘ï¼Œç”ŸæˆçœŸå€¼è¡¨å–å€¼

```go
func evaluateExpressionAndSubexpressions(expr Expr, combination map[string]bool) map[string]int {
    result := make(map[string]int)

    // è®¡ç®—å½“å‰è¡¨è¾¾å¼çš„å€¼
    if expr.Evaluate(combination) {
       result[expr.String()] = 1
    } else {
       result[expr.String()] = 0
    }

    // æ ¹æ®è¡¨è¾¾å¼ç±»å‹ï¼Œé€’å½’å¤„ç†å­è¡¨è¾¾å¼
    switch e := expr.(type) {
    case And:
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Left, combination))
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Right, combination))
    case Or:
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Left, combination))
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Right, combination))
    case Not:
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Operand, combination))
    case Implies:
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Left, combination))
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Right, combination))
    case Equivalent:
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Left, combination))
       mergeResults(result, evaluateExpressionAndSubexpressions(e.Right, combination))
    }

    return result
}
```

### 6.å°†çœŸå€¼è¡¨å¤„ç†ä¸ºJsonå¹¶è¿”å›æ•°æ®åˆ°å‰ç«¯

```go
func truthTableToJson(expr Expr, variables []string) (string, error) {
    var totalCombinations int = int(math.Pow(2, float64(len(variables))))
    results := make([]map[string]int, 0)

    for i := 0; i < totalCombinations; i++ {
       var combination = make(map[string]bool)
       for j, variable := range variables {
          // æ ¹æ®å½“å‰ç´¢å¼•iå’Œå˜é‡çš„ä½ç½®jè®¡ç®—æ¯ä¸ªå˜é‡çš„å¸ƒå°”å€¼
          combination[variable] = (i>>j)&1 == 1
       }
       // å¯¹å½“å‰çš„å˜é‡ç»„åˆæ±‚å€¼ï¼Œå¹¶è·å–è¡¨è¾¾å¼åŠå…¶å­è¡¨è¾¾å¼çš„ç»“æœ
       result := evaluateExpressionAndSubexpressions(expr, combination)
       results = append(results, result)
    }

    // å°†ç»“æœåºåˆ—åŒ–ä¸ºJSONå­—ç¬¦ä¸²
    jsonResults, err := json.Marshal(results)
    if err != nil {
       return "", fmt.Errorf("error marshalling results to JSON: %v", err)
    }
    return string(jsonResults), nil
}
```

### 7.å‰ç«¯æ ¹æ®è¿”å›çš„Jsonæ•°æ®æ¸²æŸ“çœŸå€¼è¡¨

```go
function displayTruthTable(data, tableId) {
        var truthTable = JSON.parse(data); // è§£æJson
        var table = document.getElementById(tableId);

        // æ¸…é™¤çœŸå€¼è¡¨
        table.innerHTML = "";

        // åˆ›å»ºè¡¨å¤´
        var headerRow = document.createElement("tr");
        var headerKeys = Object.keys(truthTable[0]);
        headerKeys.forEach(function (key) {
            var th = document.createElement("th");
            th.textContent = replaceLogicSymbols(key);
            headerRow.appendChild(th);
        });
        table.appendChild(headerRow);

        // åˆ›å»ºè¡¨èº«
        var tableBody = document.createElement("tbody");
        truthTable.forEach(function (row) {
            var tr = document.createElement("tr");
            headerKeys.forEach(function (key) {
                var td = document.createElement("td");
                td.textContent = row[key];
                tr.appendChild(td);
            });
            tableBody.appendChild(tr);
        });
        table.appendChild(tableBody);

        // æ·»åŠ æ¸å˜åŠ¨ç”»
        table.classList.add('loaded');
    }
```

### 8.å¯åŠ¨é¡¹ç›®

```go
func main() {
    r.GET("/api/data", ExpressHandler)
    r.LoadHTMLFiles("index.html")
    r.GET("/", func(c *gin.Context) {
       c.HTML(200, "index.html", 0)
    })
    r.Run(":8000")
}
```

## ä¸‰ã€é¡¹ç›®å¿«é€Ÿéƒ¨ç½²

### 1.æœ¬åœ°IDEå¯åŠ¨é¡¹ç›®

è¿›å…¥é¡¹ç›®æ–‡ä»¶å¤¹ï¼Œä½¿ç”¨

```
go run main.go
```

éå¸¸ç®€å•çš„å¯åŠ¨é¡¹ç›®

### 2.ç¼–è¯‘å¯æ‰§è¡Œæ–‡ä»¶

```go
$env:GOOS = "linux"//æ“ä½œç³»ç»Ÿæ ¹æ®å®é™…é€‰æ‹©
$env:GOARCH = "amd64"//æ¶æ„æ ¹æ®å®é™…é€‰æ‹©
go build -o app//ç¼–è¯‘å‡ºåä¸ºappçš„å¯æ‰§è¡Œæ–‡ä»¶
```

å¯ä»¥ç¼–è¯‘å‡ºå¯æ‰§è¡Œæ–‡ä»¶ï¼ˆä¾›æœåŠ¡å™¨ä½¿ç”¨ï¼‰ï¼ŒåŒå‡»å³å¯å¯åŠ¨é¡¹ç›®ï¼Œé€‚åˆå°ç™½é£Ÿç”¨ã€‚
